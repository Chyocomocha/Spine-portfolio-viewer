<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spine Portfolio Viewer</title>
<script src="https://unpkg.com/@esotericsoftware/spine-player@4.2/dist/iife/spine-player.js"></script>
<link rel="stylesheet" href="https://unpkg.com/@esotericsoftware/spine-player@4.2/dist/spine-player.css">
<style>
    /* 배경 투명 */
    body { margin: 0; padding: 0; background: #191919; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
    
    /* 드래그 커서 & 모바일 스크롤/확대 방지 */
    #player-container { width: 100%; height: 75vh; margin-bottom: 10px; cursor: grab; touch-action: none; }
    #player-container:active { cursor: grabbing; }

    .control-panel { width: 95%; max-width: 800px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
    .track-group { background: rgba(0, 0, 0, 0.6); padding: 15px; border-radius: 8px; flex: 1; min-width: 250px; }
    .group-title { font-weight: bold; margin-bottom: 10px; color: #ccc; text-transform: uppercase; font-size: 0.85em; border-bottom: 1px solid #555; padding-bottom: 5px; }
    .btn-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)); gap: 6px; }
    
    button { padding: 8px 5px; cursor: pointer; background: #444; color: white; border: 1px solid #555; border-radius: 4px; font-size: 0.85em; transition: 0.2s; }
    button:hover { background: #666; transform: translateY(-2px); border-color: #888; }
    
    .btn-idle { background: #2b5c8a; border-color: #3e7cb3; }
    .btn-action { background: #8a2b2b; border-color: #b33e3e; }
</style>
</head>
<body>

<div id="player-container"></div>

<div class="control-panel">
    <div class="track-group">
        <div class="group-title">Base Actions</div>
        <div class="btn-grid">
            <button class="btn-idle" onclick="resetToIdle()">Return Idle</button>
            <button class="btn-action" onclick="playAction('Action_001')">Action 1</button>
            <button class="btn-action" onclick="playAction('Action_002')">Action 2</button>
            <button class="btn-action" onclick="playAction('Signature')">Signature</button>
        </div>
    </div>
    <div class="track-group">
        <div class="group-title">Emotions</div>
        <div class="btn-grid">
            <button onclick="playEmo('Emo_Idle', true)">Emo Idle</button>
            <button onclick="playEmo('Emo_001', false)">Emo 1</button>
            <button onclick="playEmo('Emo_002', false)">Emo 2</button>
            <button onclick="playEmo('Emo_003', false)">Emo 3</button>
            <button onclick="playEmo('Emo_004', false)">Emo 4</button>
            <button onclick="playEmo('Emo_005', false)">Emo 5</button>
            <button onclick="playEmo('Emo_006', false)">Emo 6</button>
        </div>
    </div>
</div>

<script>
    let player;
    const MIX_DURATION = 0.2;
    const START_DELAY = 0.1;
    let faceTimer = null;

    // --- [IK 제어 변수] ---
    let isTouching = false;
    let faceBone = null;
    let initialFaceX = 0;
    let initialFaceY = 0;
    let inputX = 0;
    let inputY = 0;
    
    // 감도 설정
    const SENSITIVITY = 1.5; 

    const CONFIG = {
        skelUrl: "./LD_Narin.skel.bytes", 
        atlasUrl: "./LD_Narin.atlas.txt",
        baseIdle: "Idle",        
        emoIdle: "Emo_Idle",
        touchStart: "Touch_Idle_Start",
        touchLoop:  "Touch_Idle",
        touchEnd:   "Touch_Idle_End",
        boneName:   "face_con" 
    };

    new spine.SpinePlayer("player-container", {
        skelUrl: CONFIG.skelUrl,
        atlasUrl: CONFIG.atlasUrl,
        showControls: false, 
        backgroundColor: "#00000000", 
        alpha: true,                  
        premultipliedAlpha: true,

        success: function (p) {
            player = p;
            player.animationState.data.defaultMix = MIX_DURATION;

            faceBone = player.skeleton.findBone(CONFIG.boneName);
            if (faceBone) {
                initialFaceX = faceBone.x;
                initialFaceY = faceBone.y;
                console.log("IK System Ready. Bone:", CONFIG.boneName);
            }

            resetToIdle(); 
        },
        
        // --- [핵심 수정] 매 프레임 위치 업데이트 (축 변경 + 방향 반전) ---
        update: function (player, delta) {
            if (!faceBone) return;

            if (isTouching) {
                // 1. 축 변경: inputX -> Y에 적용, inputY -> X에 적용
                // 2. 방향 반전: 값 앞에 마이너스(-) 추가
                
                faceBone.x = initialFaceX + (-inputY * SENSITIVITY); 
                faceBone.y = initialFaceY + (-inputX * SENSITIVITY); 
            } else {
                // 원래 위치로 복귀
                faceBone.x += (initialFaceX - faceBone.x) * 0.1;
                faceBone.y += (initialFaceY - faceBone.y) * 0.1;
            }
        },

        error: function (p, e) {
            console.error("Error:", e);
        }
    });

    // --- 기능 함수 ---
    function resetToIdle() {
        if (!player) return;
        if (faceTimer) clearTimeout(faceTimer);
        player.animationState.setAnimation(0, CONFIG.baseIdle, true);
        player.animationState.setAnimation(1, CONFIG.emoIdle, true);
    }

    function playAction(animName) {
        if (!player) return;
        if (faceTimer) clearTimeout(faceTimer);

        const entry = player.animationState.setAnimation(0, animName, false);
        const actionDuration = entry.animation.duration;
        
        player.animationState.addAnimation(0, CONFIG.baseIdle, true, 0);

        faceTimer = setTimeout(() => {
            player.animationState.setEmptyAnimation(1, MIX_DURATION);
            let returnDelay = actionDuration - MIX_DURATION - START_DELAY - 0.15;
            if (returnDelay < 0) returnDelay = 0;
            player.animationState.addAnimation(1, CONFIG.emoIdle, true, returnDelay);
        }, (START_DELAY * 1000)); 
    }

    function playEmo(animName, loop) {
        if (!player) return;
        if (isTouching) return; 
        if (faceTimer) clearTimeout(faceTimer);
        player.animationState.setAnimation(1, animName, loop);
    }

    // --- [터치/드래그 이벤트 핸들러] (일시정지 방지 적용됨) ---
    const container = document.getElementById("player-container");

    function startInput(e) {
        e.stopPropagation(); // 일시정지 차단
        
        if (!player || isTouching) return;
        
        isTouching = true;
        if (faceTimer) clearTimeout(faceTimer); 
        updateInputPosition(e);

        player.animationState.setAnimation(1, CONFIG.touchStart, false);
        player.animationState.addAnimation(1, CONFIG.touchLoop, true, 0);
    }

    function endInput(e) {
        if (!player || !isTouching) return;
        
        if(e) e.stopPropagation();

        isTouching = false;
        inputX = 0; 
        inputY = 0;

        player.animationState.setAnimation(1, CONFIG.touchEnd, false);
        player.animationState.addAnimation(1, CONFIG.emoIdle, true, 0);
    }

    function moveInput(e) {
        if (isTouching) {
            e.stopPropagation();
            if(e.type === 'touchmove') e.preventDefault(); 
            updateInputPosition(e);
        }
    }

    function updateInputPosition(e) {
        const rect = container.getBoundingClientRect();
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        let clientX, clientY;
        if (e.touches && e.touches.length > 0) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        inputX = (clientX - rect.left) - centerX;
        inputY = (clientY - rect.top) - centerY;
    }

    // 이벤트 우선권 확보
    container.addEventListener("mousedown", startInput, { capture: true });
    window.addEventListener("mousemove", moveInput, { capture: true });
    window.addEventListener("mouseup", endInput, { capture: true });

    container.addEventListener("touchstart", startInput, { capture: true, passive: false });
    window.addEventListener("touchmove", moveInput, { capture: true, passive: false });
    window.addEventListener("touchend", endInput, { capture: true });

</script>

</body>
</html>